
The core \MACI library is a \CPP library. The functionality of the library is exported to \PYTHON using \SWIG.

As a third-level, the \PYTHON module has been enhanced with \XML parsing capabilities allowing users to specify the majority of simulation parameters in a portable human-readable format. The ability to parse \XML files has been added late to the code. It is the authors experience that while scripting languages are well suited to describe the simulation flow, the inclusion of simulation parameters typically leads to bad maintainable scripts due to repeated changes, e.g.~when a parameter space is to be explored. In our experience the separation of the simulation flow (in the form of \PYTHON modules and scripts) and simulation parameters (in the form of \XML files) is a reasonable approach to reduce complexity in the scientific workflow. This is especially important in multiscale simulations where three different domain codes (MD, FE and coupling code) must be handled in a consistent way.

\MACI implements the coupling method first introduced by \citet{FackeldeyKrauseKrauseLenzen2011}. It implements Least-Squares and $L^2$ projection-based coupling. On the \PYTHON level a RATTLE time integration scheme and a multirate time integration scheme are implemented. 

\MACI uses a generic interface to communicate with the FE and MD code. This interface has been designed with some assumptions on the commodity codes but is generic enough to be implemented by many different codes. Currently, \MACI can interface to Sandia's \LAMMPS MD code, the \TREMOLO MD code developed at the University of Bonn and the UG Finite Element code (with some restrictions). Additionally, \MACI uses various third-party packages such as \TRILINOS, \PETSC or \UMFPACK to solve arising linear systems. 
